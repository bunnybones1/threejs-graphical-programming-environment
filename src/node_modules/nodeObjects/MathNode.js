var THREE = require('three');

var randomFromArray = require('utils/array/randomFromArray');
var BaseNode = require('./BaseNode');
var esprima = require('esprima');
var clamp = require('clamp');

var mathMethods = {
	"*": function product(a, b) {
		return a * b;
	},
	"/": function quotient(a, b) {
		return a / b;
	},
	"+": function sum(a, b) {
		return a + b;
	},
	"++": function plusplus(a) {
		return ++a;
	},
	"-": function difference(a, b) {
		return a - b;
	},
	"%": function modulo(a, b) {
		return a % b;
	},
	floor: function floor(a) {
		return Math.floor(a);
	},
	ceil: function ceiling(a) {
		return Math.ceil(a);
	},
	round: function round(a) {
		return Math.round(a);
	},
	sin: function sine(a) {
		return Math.sin(a);
	},
	cos: function cosine(a) {
		return Math.cos(a);
	},
	clamp: clamp,
	pi: Math.PI,
	'1': 1,
	'0': 0,
	'1000': 1000
};


var __colorNormal = new THREE.Color(0.4, 0.6, 0.4);
var __colorHighlight = new THREE.Color(0.6, 0.8, 0.4);

function MathNode(key) {
	this.colorNormal = this.colorNormal || __colorNormal;
	this.colorHighlight = this.colorHighlight || __colorHighlight;

	BaseNode.call(this);

	if(!key) {
		key = randomFromArray(Object.keys(mathMethods));
	} else if(Object.keys(mathMethods).indexOf(key) === -1) {
		throw new Error('Unsupported: ' + key);
	}

	var inputCount = 0;
	var outputCount = 1;
	var mathMethod = mathMethods[key];
	this.transformMethod = mathMethod;
	if(typeof mathMethod === 'function') {
		var methodDescription = esprima.parse(String(mathMethod));
		inputCount = methodDescription.body[0].params.length;
	}

	this.label.updateText(key);

	for (var i = 0; i < inputCount; i++) {
		this.addInput();
	}
	for (var i = 0; i < outputCount; i++) {
		this.addOutput();
	}

}

MathNode.prototype = Object.create(BaseNode.prototype);


module.exports = MathNode;
