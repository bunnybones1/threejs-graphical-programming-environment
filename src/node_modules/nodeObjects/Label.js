var THREE = require('three');

var bmfont = require('three-bmfont-text');
var MSDFShader = require('three-bmfont-text/shaders/msdf');

var __font;
var __texture;
function __getGeometry(labelStr) {
	var geom = bmfont({
		text: labelStr,
		font: __font,
		align: 'center',
		flipY: __texture.flipY
	});

	var layout = geom.layout;

	var heightDrop = -layout.descender + layout.height + (layout.baseline - layout.ascender) * 0.5;
	var offsetX = layout.width * -0.5;
	// debugger;
	var posArr = geom.attributes.position.array;
	for (var i = 1; i < posArr.length; i += 2) {
		posArr[i] += heightDrop;
	}

	for (var i = 0; i < posArr.length; i += 2) {
		posArr[i] += offsetX;
	}

	return geom;
}

var __material = null;
function __getMaterial() {
	if(!__material) {
		__material = new THREE.RawShaderMaterial(
			MSDFShader({
				map: __texture,
				transparent: true,
				color: 0xffffff,
				depthWrite: false,
				depthTest: false,
				side: THREE.DoubleSide
			})
		);
	}
	return __material;
}
function __initFont(font, texture) {
	__font = font;
	__texture = texture;
}


function Label(labelStr) {
	var geom = __getGeometry(labelStr);
	// var text = new THREE.Mesh(geom, __getMaterial());

	// var textAnchor = new THREE.Object3D();
	// textAnchor.add(text)
	// textAnchor.rotation.z = angle
	// container.add(textAnchor)



	// var geom = new THREE.SphereGeometry(0.4, 8, 6);
	// var mat = new THREE.MeshBasicMaterial({
	// 	color: 0xffffff,
	// 	transparent: true,
	// 	depthWrite: false,
	// 	depthTest: false,
	// 	wireframe: true
	// });
	THREE.Mesh.call(this, geom, __getMaterial());
	this.ignoreHitTest = true;
	this.renderOrder = 1000;
}

Label.prototype = Object.create(THREE.Mesh.prototype);

Label.prototype.updateText = function(textString) {
	if(this.lastTextString === textString) return;
	this.geometry.dispose();
	this.geometry = __getGeometry(textString);
	this.lastTextString = textString;
};

Label.initFont = __initFont;
module.exports = Label;
