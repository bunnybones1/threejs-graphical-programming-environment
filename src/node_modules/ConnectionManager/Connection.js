var THREE = require('three');
var decorateMethodBefore = require('utils/decorateMethodBefore');

var __lineGeometry = new THREE.BufferGeometry();
__lineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

var __color = new THREE.Color(0.75, 0.75, 0.75);
var __lineMaterial = new THREE.LineBasicMaterial( {
	color: __color,
	depthWrite: false,
	depthTest: false,
} );

var __color2 = new THREE.Color(1, 1, 0.75);
var __lineMaterialSelected = new THREE.LineBasicMaterial( {
	color: __color2,
	depthWrite: false,
	depthTest: false,
} );

var __delta = new THREE.Vector3();
var __tempVec3 = new THREE.Vector3();

function __updateConnectionMatrix(fromObj, toObj) {
	this.position.copy(fromObj.position);
	this.position.applyMatrix4(fromObj.parent.matrixWorld);

	__tempVec3.copy(toObj.position);
	__tempVec3.applyMatrix4(toObj.parent.matrixWorld);

	this.lookAt(__tempVec3);

	__delta.copy(this.position).sub(__tempVec3);
	var len = __delta.length();
	this.scale.set(len, len, len);
}

function Connection(fromObj, toObj) {
	THREE.Line.call(this, __lineGeometry, __lineMaterial );
	this.nodes = [fromObj, toObj];
	fromObj.connections.push(this);
	toObj.connections.push(this);
	this.renderOrder = 1000;

	decorateMethodBefore(this, 'updateMatrix', __updateConnectionMatrix.bind(this, fromObj, toObj));
}

Connection.prototype = Object.create(THREE.Line.prototype);

Connection.prototype.highlight = function() {
	this.material = __lineMaterialSelected;
};

Connection.prototype.unhighlight = function() {
	this.material = __lineMaterial;
};

module.exports = Connection;
